import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.oauth2.client.*;
import org.springframework.security.oauth2.client.registration.ClientRegistration;
import org.springframework.security.oauth2.client.registration.ReactiveClientRegistrationRepository;
import org.springframework.security.oauth2.client.web.server.ServerOAuth2AuthorizedClientRepository;
import org.springframework.security.oauth2.core.OAuth2AccessToken;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

@Component
public class BffTokenAndUserFilter implements GlobalFilter, Ordered {

    private final ReactiveOAuth2AuthorizedClientManager authorizedClientManager;

    @Autowired
    public BffTokenAndUserFilter(
            ReactiveClientRegistrationRepository clientRegistrations,
            ReactiveOAuth2AuthorizedClientService authorizedClientService) {

        ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =
                ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
                        .clientCredentials()
                        .build();

        this.authorizedClientManager = new AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager(
                clientRegistrations, authorizedClientService);
        this.authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);
    }

    @Override
    public int getOrder() {
        return 200; // après la sécurité
    }

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {

        // 1️⃣ récupère le token OAuth2 client_credentials du BFF
        OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest
                .withClientRegistrationId("bff")
                .principal("bff-client")
                .build();

        Mono<ServerHttpRequest> modifiedRequestMono = this.authorizedClientManager.authorize(authorizeRequest)
                .map(authorizedClient -> {
                    OAuth2AccessToken accessToken = authorizedClient.getAccessToken();
                    ServerHttpRequest request = exchange.getRequest()
                            .mutate()
                            .header("Authorization", "Bearer " + accessToken.getTokenValue())
                            .build();
                    return request;
                })
                .defaultIfEmpty(exchange.getRequest());

        // 2️⃣ récupère l'email de l'utilisateur si connecté
        Mono<ServerHttpRequest> finalRequest = modifiedRequestMono.flatMap(request ->
                ReactiveSecurityContextHolder.getContext()
                        .filter(c -> c.getAuthentication() != null)
                        .map(c -> {
                            if (c.getAuthentication() instanceof JwtAuthenticationToken jwt) {
                                String userEmail = (String) jwt.getTokenAttributes().get("email");
                                return request.mutate().header("x-user", userEmail).build();
                            }
                            return request;
                        })
                        .defaultIfEmpty(request)
        );

        return finalRequest.flatMap(request -> chain.filter(exchange.mutate().request(request).build()));
    }
}
